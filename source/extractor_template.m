% extractor_template.m
% Clayton Kotulak
% 12/14/2015

%{ 
Return a list of template tiles generated by decomposing instances contained
in sample_data.

Arguments: data struct
Returns: tiles struct
%}
function tiles = extractor_template(sample_data)

	global PARAMS;
	
	disp("\nExtracting template tiles...");
	
	% Select a random set of sample instances to use in evaluating templates
	eval_data = extractor_subset(sample_data, PARAMS.template_eval_n);
	inhibit_tiles = extractor_decompose(eval_data.inhibit_data);	
	excite_tiles = extractor_decompose(eval_data.excite_data);
	
	% Select template_n instances to extract template tiles from
	template_data = extractor_subset(sample_data, PARAMS.template_n);
	inhibit_tiles = extractor_decompose(template_data.inhibit_data);
	excite_tiles = extractor_decompose(template_data.excite_data);
	template_tiles = [inhibit_tiles; excite_tiles];
	
	% Only keep unique row-vector tiles
	template_tiles = unique(template_tiles, 'rows');
	
	
	% Compute template biases and add to tiles collection
	template_norm = extractor_normalize(template_tiles);
	template_ext = [template_norm (1 .- template_norm)];
	template_ext = template_ext ./ sum(template_ext, 2);
	
	inhibit_norm = extractor_normalize(inhibit_tiles);
	inhibit_ext = [inhibit_norm (1 .- inhibit_norm)];
	inhibit_ext = inhibit_ext ./ sum(inhibit_ext, 2);
	
	excite_norm = extractor_normalize(excite_tiles);
	excite_ext = [excite_norm (1 .- excite_norm)];
	excite_ext = excite_ext ./ sum(excite_ext, 2);
	
	inhibit_sum = sum(template_ext * inhibit_ext', 2);
	excite_sum = sum(template_ext * excite_ext', 2);
	
	tile_bias = excite_sum .- inhibit_sum;
	
	if (PARAMS.db_display)
		bias_positive = tile_bias(tile_bias>0);
		bias_negative = tile_bias(tile_bias<=0);
		
		min_val = min(bias_negative);
		max_val = max(bias_negative);
		mean_val = mean(bias_negative);
		fprintf("Negative bias min: %4d, max: %4d, mean: %4d\n",...
				min_val, max_val, mean_val);

		min_val = min(bias_positive);
		max_val = max(bias_positive);
		mean_val = mean(bias_positive);
		fprintf("Positive bias min: %4d, max: %4d, mean: %4d\n",...
				min_val, max_val, mean_val);
		
		fprintf("Negative tiles: %d, positive tiles: %d, zero tiles: %d\n",...
				sum(tile_bias<0), sum(tile_bias>0), sum(tile_bias==0)); 
		fflush(stdout);
	end
	

	excite_mask = (tile_bias>0);
	excite_tiles = template_tiles(excite_mask, :);
	excite_bias = tile_bias(excite_mask);
	
	tile_n = min([PARAMS.template_tiles sum(excite_mask)]);
	
	% Initialize similarity for all templates to one
	similarity = ones(sum(excite_mask), 1);
	
	tiles = [];
	tiles_ext = [];
	template_ext = template_ext(excite_mask, :);
	
	% Select up to template_tiles template tiles from excite_tiles
	for i=1:tile_n
		[val template_idx] = max(excite_bias .* similarity);
		tiles = [tiles; excite_tiles(template_idx, :)];
		
		tiles_ext = [tiles_ext; template_ext(template_idx, :)];
		template_ext(template_idx, :) = [];
		excite_tiles(template_idx, :) = [];
		excite_bias(template_idx) = [];
		
		if (numel(template_ext) > 0)
			similarity = sum(template_ext * tiles_ext', 2);
			similarity = extractor_normalize(-1 .* similarity, 1);
		else
			break;
		end
	end
	
	% Debug... is the above effective? Select random tiles...
	if (0)
		rand_vals = rand(size(template_tiles, 1), 1);
		[vals idx] = sort(rand_vals);
		tiles = template_tiles(idx(1:tile_n), :);
	end
	
	disp("Tile extraction complete.\n");
	
end

